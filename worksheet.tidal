-- Mini-notation worksheet, number one!

-- Play a "kick" sound (the first one in the folder)
d1 $ sound "kick"

-- Play a different sound from the "kick" folder (the fourth one, counting from zero)
d1 $ sound "kick:3"

-- Play a kick - snare loop. Notice two sounds fit in the same time as one did above
d1 $ sound "kick snare"

-- The more you add, the faster it goes - the 'cycle' stays constant
d1 $ sound "kick snare kick snare"

d1 $ sound "kick snare kick snare kurt hi lo hi lo"

-- Again, we can pick sounds with : and a number

d1 $ sound "cpu:0 cpu:2 cpu:4 cpu:6 cpu:0 cpu:2 cpu:6 cpu:8"

-- If they're all from the same folder, it's easier to pattern
-- the sounds using a separate "n" pattern, like this:
d1 $ n "0 2 4 6 0 2 6 8" # sound "cpu"

-- `#` combines together patterns of different kinds, in this case a 'sound'
-- and an 'n' pattern.
-- We'll come back to `#` (and how it differs from '$') in the future!

-- You can have an 'empty' step, known as a musical rest, with '~'
d1 $ sound "kick snare ~ clap:4"

d1 $ n "0 2 2 ~ 8 ~ 8 ~" # sound "cpu"

-- You can also "break down" a step into a subsequence, with []

-- Lets start with a simple pattern
d1 $ sound "hi lo hi lo"

-- And squeeze a two-step subsequence inside that third step:
d1 $ sound "hi lo [hi hi] lo"

-- It works for 'n' patterns too
d1 $ n "0 1 [5 5 5] 4" # sound "drum"

-- You can even break down a step inside a subsequence:
d1 $ sound "hi lo [hi [hi lo hi lo]] lo"

-- It's easy to make nice compount time signatures:
d1 $ sound "[hi lo hi] [hi lo hi lo]"

-- SPEEDING UP, REPEATING, AND SLOWING DOWN

-- SPEEDING UP A STEP WITH "*"
-- https://www.youtube.com/watch?v=h_f11uago28&t=105s

-- Make a step go 'faster', so it repeats itself within its step:
d1 $ sound "hi lo*3"

-- It works with subsequences too
d1 $ sound "hi [hi lo]*2"

-- And 'n' patterns
d1 $ n "[0 ~ 0] 2 [0 9]*2 2" # sound "cpu"

-- Let's try speeding up a pattern by one-and-a-half:
d1 $ sound "bd [sd hc]*1.5"

-- It has two steps, so if you speed it up by 1.5, you get three steps.
-- The first time around you get "bd [sd hc sd]", the second time "bd [hc sd hc]"

-- SLOWING DOWN A STEP WITH "/"
-- https://www.youtube.com/watch?v=h_f11uago28&t=346s

-- Make 'lo' sound only every other cycle:
d1 $ sound "hi lo/2"

-- Make 'lo' sound only every third cycle:
d1 $ sound "hi lo/3"

-- Slow down a subsequence, so only one step sounds per cycle:
d1 $ sound "clap [numbers:0 numbers:1 numbers:2]/3"

-- Take two steps from a six step sequence each cycle, by slowing it by 3:
d1 $ n "0 0 0 [0 1 3 4 5 6]/3" # sound "cpu2"

-- Make things strange by slowing down with funky ratios!
d1 $ n "0 0 0 [0 1 3 4 5 6]/2.5" # sound "cpu2"

-- REPEATING A STEP WITH "!"
-- https://www.youtube.com/watch?v=h_f11uago28&t=275s

-- If you want to repeat steps on the same metrical level, then you can use ! ..
-- So this:
d1 $ sound "hi lo!3"

-- Is the same as this:
d1 $ sound "hi lo lo lo"

-- You can also use an ! on its own for a single repeat. So this:
d1 $ sound "hi lo !"

-- Is the same as this:
d1 $ sound "hi lo lo"

-- You can repeat subsequences too, so these are the same:
d1 $ sound "bd bd [hi lo] !"

d1 $ sound "bd bd [hi lo] [hi lo]"

-- POLYPHONY WITH ","
-- https://www.youtube.com/watch?v=h_f11uago28&t=668s

-- With ',' you can have more than one subsequence happening at the same time.
-- Where you have the possibility of more than one note happening at once,
-- that's called musical "polyphony"

-- This is like where you have multiple channels d1 and d2 active at the same time:
d1 $ sound "bd sd"

d2 $ sound "rs rs rs"

-- .. but with ","" you can put them both in the same pattern. This sounds
-- the same as the two above patterns playing at once:
d1 $ sound "[bd sd, rs rs rs]"

-- The subsequences line up to fill the same cycle.
-- So "[a b, c d e]" lines up like this:
-- |a--b--|
-- |c-d-e-|

-- There's an 'alphabet' sample set in the default samples that can help with
-- this!
d1 $ n "[0 1, 2 3 4]" # sound "alphabet"

-- There's another way of getting subsequences to align, using { } instead of [ ]:
d1 $ n "{0 1, 2 3 4}" # sound "alphabet"

-- Video explanation: https://www.youtube.com/watch?v=h_f11uago28&t=822s

-- The first three cycles of this looks like this:
-- |ababab|
-- |cdecde|

-- What's happening? Well Tidal aligns the first subsequence, "0 1", to fit
-- the cycle, as before. But then it fits the others to it *stepwise*. So
-- now the steps align, but the cycles don't! In the space of three
-- cycles, there are three repetitions of "a b" and two repetitions of "c d e"

-- The [ ] notation creates what is called a musical 'polyrhythm' - multiple
-- rhythms happening within the same timeframe, e.g.:
d1 $ n "[0 5 2 ~, 0 3 4*2 0 3]" # sound "cpu2"

-- The { } notation creates a 'polymetre' - where metres of different durations
-- phase in and out of each other, e.g.:
d1 $ n "{0 5 2 ~, 0 3 4*2 0 3}" # sound "cpu2"

-- I (Alex) get mixed up between polyrhythm and polymetre all the time, and
-- tend to just call them both polyrhythm for simplicity..

-- 'Traditional' music software with linear 'piano roll' style notation systems
-- can really struggle with polyrhythm/metre, but it's really easy with Tidal
-- and a *lot* of fun to explore.

-- RHYTHMIC FEET WITH "."
-- https://www.youtube.com/watch?v=h_f11uago28&t=988s

-- You can 'mark out' regular rhythmic 'feet' with "."

-- So this:
d1 $ sound "bd sd . mt ht lt . arpy arpy:4 . snare clap:4 bd"

-- Is another way of saying exactly this:
d1 $ sound "[bd sd] [mt ht lt] [arpy arpy:4] [snare clap:4 bd]"

-- So the "." breaks up a sequence into parts of equal duration

-- To break down a step _within_ the "." notation, you can still
-- use [], etc:
d1 $ sound "bd sd . mt [ht mt] lt . arpy [arpy:4 arpy:5] . snare clap:4 bd"

-- That's the same as:
d1 $ sound "[bd sd] [mt [ht mt] lt] [arpy [arpy:4 arpy:5]] [snare clap:4 bd]"

-- ONE STEP PER CYCLE WITH "<>"
-- https://www.youtube.com/watch?v=h_f11uago28&t=1166s

-- Often it's nice to pick one step from a subsequence every cycle.
-- One way is this:
d1 $ sound "hi [arpy arpy:1 arpy:2 arpy:3]/4"

-- You can do the same thing with < > - it picks one step per cycle, without
-- you having to worry about how many steps there are inside:
d1 $ sound "hi <arpy arpy:1 arpy:2 arpy:3>"

-- REVISION TASKS

-- Copy each of the following patterns in turn, and edit them so that they
-- are shorter, using the "<>", "!", "[]" and/or "." introduced above.

d1 $ sound "kick snare snare"

d1 $ sound "kick [snare snare]"

d1 $ sound "kick snare kick snare kick snare"

d1 $ n "0 [1 2 3]/3" # sound "cpu2"

d1 $ n "[0 0 2] [4 5 6 7] [4 1] [0 3 0 3]" # sound "cpu2"

d1 $ sound "kick snare kick snare kick snare clap"

d1 $ sound "[kick snare kick snare kick snare] clap"

d1 $ sound "bd sd sd sd bd [sd sd sd]"

-- Trying to make code as short as possible is called "golfing" for some reason.
-- It can be useful as a form of practice, but sometimes longer code
-- is actually much easier to understand and edit!

-- Tidal has lots of effects we can use to change the way things sound.

-- vowel is a filter which adds a vowel sound
-- try a, e, i, o and u

d1 $ n "0 1 0 [2 4] 2 4 1*2 3" # s "cpu"

d1 $ n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu" # vowel "a"

d1 $ n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu" # vowel "o"

-- We can use the mini notation to create sequences of effects too:

d1 $ n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu" # vowel "a o e"

-- Tidal does its best to map patterns across to one another.

-- You can add a non-vowel letter to pause the vowel effect

d1 $ n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu" # vowel "a p"

-- 'squiz' is a nice distortion effect
d1 $ n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu" # squiz "4 1 0 3"

-- With '#' structure comes from the left - try swapping the parameters around

d1 $ squiz "4 1 0 3" # n "0 1 0 [2 4] 2 ~ 1*2 3" # s "cpu"

-- Now there are only four sounds per cycle, because there's four in the leftmost
-- 'squiz' pattern

-- We'll learn more about how things in patterns get matched up later!

-- 'gain' changes the volume of different sounds

d1 $ sound "kick kick snare snare" # gain "1 0.7 0.6 0.5"

d1 $ sound "[hh*16, kick:8 snare:4 [~ kick:8] snare]" # gain "[1 1.2]*8"

-- speed can be used to pitch samples
-- (we can also use 'note' to do this, but we'll look at that later)

-- speed changes the speed of playback,
-- e.g. 2 = play the sample twice as fast - which moves the note up an octave

d1 $ sound "numbers:1 numbers:2 numbers:3 numbers:4" # speed "1 1.5 2 0.5"

-- Or we can take the pattern from the speed parameter

d1 $ speed "1*2 2*2 4*6" # sound "jungbass:6"

-- pan allows us to create stereo effects - 0 = left, 0.5 = middle, 1 = right

d1 $ sound "numbers:1 numbers:2 numbers:3 numbers:4" # pan "0 0.5 1"

-- shape adds distortion (but be careful - it also makes the sound much louder)

d1 $ sound "kurt:4 kurt:4"

d1 $ sound "kurt:4(3,8)" # shape "0 0.98" # gain "0.7"


-- Time to look at Time

-- "Music is the Time of Numbers"

-- setcps - change global tempo

-- Let's run two patterns at once:
d1 $ n "0 2 [3 5] [4 7]" # sound "cpu"

d2 $ n "0(3,8) 8*8" # sound "cpu2"
  # squiz 5

-- Changing the cps (cycles per second) changes everything
setcps 0.7

setcps 0.3

-- Time as an effect (!)

-- You can also set cps as an effect:
d2 $ n "0(3,8) 8*8" # sound "cpu2"
  # squiz 5
  # cps 0.5

-- It's still global though - setting it on one pattern will
-- change it everywhere

-- However, you can pattern it:
d2 $ n "0(3,8) 8*8" # sound "cpu2"
  # squiz 5
  # cps "0.5 1"

-- You can really mess with time in this way!
d2 $ n "0 [~ 1] 2*2 3 4*3 5 ~ 7" # sound "cpu2"
    # cps "<0.5 2> [1 0.75] <2 1>"

-- Reset things before moving on..
hush

setcps 0.6

-- 'fast' and 'slow' functions

-- You can speed up / slow down an individual
-- pattern (or part of one) with "fast" and "slow"


d1 $ slow 2 $ n "0 2 [3 5] [4 7]" # sound "cpu"

d1 $ fast 2 $ n "0 2 [3 5] [4 7]" # sound "cpu"

-- You can also pattern this speed factor:
d1 $ slow "0.5 1" $ n "0 2 [3 5] [4 7]" # sound "cpu"

d1 $ slow "0.5 <1 2>" $ n "0 2 [3 5] [4 7]" # sound "cpu"

-- When patterning time in this way, you're switching
-- between different versions of the pattern, running
-- at different speeds.

-- We've already learned enough to create patterns with a
-- lot of variety in them, by mixing together several simple
-- manipulations
d1 $ slow "0.5 <1 2>" $
  n "{0 2 [3 5] [4 <7 6>], 0*2 3*3 0}" # sound "cpu"
  # squiz "<8 1 2>"

-- Note that the 'speed' effect changes the rate of playback
-- for each sample, but doesn't change the overall speed of the
-- pattern
d1 $ slow "0.5 <1 2>" $
    n "{0 2 [3 5] [4 <7 6>], 0*2 3*3 0}" # sound "cpu"
    # squiz "<8 1 2>"
    # speed 2

-- I find things always sound better if you speed them up a little.
-- Your experience may vary :)
setcps 0.7


-- Ok, so what happens when we specify a 'control' pattern (like e.g. n,
-- sound, speed, or squiz) more than once?

-- Lets start with the handy 'numbers' sounds:
d1 $ n "0 1 ~ 2" # sound "numbers"

-- lets put than 'n' again, but with a different number:
d1 $ n "0 1 ~ 2" # sound "numbers" # n "4"

-- So.. you can hear that we still have the rhythmic structure from
-- the left, but all the values have been replaced with the one on the
-- right. That's what `#` does!

-- lets make that right hand pattern more complicated:
d1 $ n "0 1 ~ 2" # sound "numbers" # n "4 5"

-- Now the 0 and 1 have been replaced with the 4, and the 2 has been
-- replace with the 5.

-- This is because tidal matches them up for you, based on where they
-- are in the cycle. The 0 and 1 start inside the first half, so are
-- replaced with '4'. The 2 starts inside the second half, so is
-- replace by '5'.

-- # is actually shorthand, for '|>'. There's a whole family of these:

-- |> is structure from the left, values from the right
-- <| is values from the left, structure from the right
-- |< is structure from the left, values from the left
-- >| is structure from the right, values from the right
-- |<| is values from the right, structure from both sides
-- |>| is values from the left, structure from both sides

-- < points to where the values come from, and | goes on the side where the
-- rhythmic structure comes from.

-- Everything from the left:
d1 $ n "0 1 2 3" # sound "numbers" |< n "4 5"

-- Everything from the right:
d1 $ n "0 1 2 3" # sound "numbers" >| n "4 5"

-- Rhythmic structure from left, values from the right:
d1 $ n "0 1 2 3" # sound "numbers" |> n "4 5"

-- Values from the left, rhythmic structure from right:
d1 $ n "0 1 2 3" # sound "numbers" <| n "4 5"

-- Values from the left, rhythmic structure from both sides:
d1 $ n "0 1 2 3" # sound "numbers" |<| n "4 5"

-- The above use of |<| sounds the same as |<, because the rhythmic
-- structures line up.

-- This changes
d1 $ n "0 1 2" # sound "numbers" |>| n "4 5"

-- Some gotchas!

-- Even though you are taking everything from one side, something
-- still has to match up on the other side..
-- So this makes no sound:
d1 $ n "~" # sound "numbers" >| n "4 5"

-- Only the '4' sounds here:
d1 $ n "0 ~" # sound "numbers" >| n "4 5"

-- Most of the time you'll be fine forgetting all this, and just using
-- |> , and its alias # .

-- However, there are other things you can do!

-- Instead of taking values from one side, you can add the values together, by
-- using '+' instead of '>' or '<'.

-- This:
d1 $ n "0 1 2 3" # sound "numbers" |+ n "4 5"

-- adds up to:
d1 $ n "4 5 7 8" # sound "numbers"

-- This:
d1 $ n "0 1 2 3" # sound "numbers" +| n "4 5"

-- adds up to:
d1 $ n "4 7" # sound "numbers"

-- This is because the rhythm comes from the left, from the "4 5", and
-- so we start from that. The start of 4 matches with 0, and the start
-- of 5 matches with 2, and adding them up, we end up with 4+0=4, and
-- 5+2 = 7.

-- This all gets complicated, especially when you work with patterns
-- with different numbers of steps..

d1 $ n "0 1 2 3" # sound "numbers" |+ n "4 5 6"

-- But don't worry too much. You just have to say what you want to
-- add together, let Tidal worry about working it out for you!

-- Ok that's enough numbers, lets put this into action with some
-- interesting patterns.

-- Here's one adding together 'n' patterns, using |+| to take
-- structure from both sides. On the right hand side, it uses the < >
-- mininotation syntax to pick a different subsequence per cycle.
-- The result is an interesting, longer form pattern:

d1 $ n "0 1 2 [3 5]" # sound "cpu"
  |+| n "<[4 5 3 2] [5 4 3] [6 5]>"
  # squiz 2

-- I just added a bit of squiz there to make it sound nice.

-- Here's a simpler example, cycling between three 12 note octaves, one per cycle:
d1 $ n "7 5 [2 7] 0" # sound "superpiano"
  |+ n "<-12 0 12>"

-- It's actually possible to apply these to patterns of numbers
-- _before_ they become control patterns, like this:
d1 $ n ("7 5 [2 7] 0" |+ "<-12 0 12>") # sound "superpiano"

-- You have to use parenthesis to make sure the two patterns are added
-- together, before being passed to the 'n'.

-- To be clear, this is a pattern of numbers:
-- "7 5 [2 7] 0"

-- This is a control pattern, because 'n' turns numbers into synthesiser
-- control patterns:
-- n "7 5 [2 7] 0"

-- This all works for effects too:
d1 $ n "0(5,8) [4 1]" # sound "drum"
  # squiz "0 2 5"
  |+ squiz "<0 2 3>"

-- Or again, you can add the number patterns, rather than the control
-- patterns. This is the same:
d1 $ n "0(5,8) [4 1]" # sound "drum"
  # squiz ("0 2 5" |+ "<0 2 3>")

-- See which you prefer to do!

-- 'saw' is a pattern that slowly moves from 0 to 1 over a cycle. Here
-- I'm slowing it down so it lasts 4 cycles, slowing increasing the
-- speed over that time:
d1 $ n "[0 4 2] [4 1] 3 [2 0] 3 [3 1] 4 4" # sound "cpu"
  # squiz 3
  # speed "1 [2 3] 3"
  |+ speed (slow 4 saw)


-- every

-- 'every' is one of a family of Tidal functions, that takes another
-- function as one of its inputs.

-- Let's say we had a simple pattern like this:
d1 $ sound "bd sd ~ cp"

-- ... and we wanted to speed it up like this:
d1 $ fast 2 $ sound "bd sd ~ cp"

-- ... but only one cycle out of three.

-- Here's how we'd use 'every' to do that:
d1 $ every 3 (fast 2) $ sound "bd sd ~ cp"

-- You can read this as "every 3rd cycle, make 'sound "bd sd ~ cp"',
-- go faster by a factor of two."

-- We'll take this apart to work out why we sometimes use (), and
-- sometimes '$' later. First, lets look at more, practical examples
-- of using 'every'.

-- We can use every with any function that takes single pattern as
-- input (and returns a transformed version as output). For example,
-- we can use 'hurry' instead of fast:
d1 $ every 3 (hurry 2) $ sound "bd sd [~ bd] [cp bd*2]"

-- Or use 'rev':
d1 $ every 3 (rev) $ sound "bd sd [~ bd] [cp bd*2]"

-- Because 'rev' is a single word, we don't actually need to put it in
-- parenthesis:
d1 $ every 3 rev $ sound "bd sd [~ bd] [cp bd*2]"

-- Here's a trick with using effects as functions..
-- Lets look at this:
d1 $ sound "bd sd [~ bd] [cp bd*2]"
   # squiz "5"

-- We can treat the '# speed 5' bit as a function. If you think about
-- it, it does something to a pattern, just like 'fast 2' does.

-- So.. does this work?
d1 $ every 3 (# squiz 5) $ sound "bd sd [~ bd] [cp bd*2]"

-- Yes it does!

-- You can also add more than one 'every' manipulation, giving them
-- different periods for their first input, to create longer form
-- variety:
d1 $ every 3 (# squiz 5) $ sound "bd sd [~ bd] [cp bd*2]"

d1 $ every 2 (hurry 2) $ every 3 (# squiz 5) $ sound "bd sd [~ bd] [cp bd*2]"

-- keep going..
d1 $ every 4 rev $ every 2 (hurry 2) $ every 3 (# squiz 5)
   $ sound "bd sd [~ bd] [cp bd*2]"

-- In Tidal, the pattern that a function is manipulating is generally
-- its final input, which makes it easy to 'chain together' functions
-- like this.

-- Ok as promised, lets go back to our original, simple example:
d1 $ every 3 (fast 2) $ sound "bd sd ~ cp"

-- Lets go through the three 'inputs' (also sometimes called
-- 'parameters' or 'arguments') for every.

-- [a] 3 - how often a function is applied
-- [b] fast 2 - the function that is applied
-- [c] sound "bd sd ~ cp" - the pattern that it's applied to.

-- Looking again at this pattern, you can see that the inputs are
-- given in three different ways:
d1 $ every 3 (fast 2) $ sound "bd sd ~ cp"

-- '3' is just on its own. It's a single number so tidal has no
-- problem knowing it's a single input.

-- 'fast 2' is in parenthesis '(fast 2)'. Then the word 'fast' and
-- number '2' are grouped together into a function, _before_ being
-- passed to 'every' as its second input.

-- 'sound "bd sd ~ cp"' has $ in front. We *could* have done this
-- instead:
d1 $ every 3 (fast 2) (sound "bd sd ~ cp")

-- That works fine, but '$' does the same kind of job. It passes
-- what's on its left, to the function on its right, as a single
-- parameter. '$' has really low priority, which means everything on
-- its right is worked out first before being passed to the left.
d1 $ every 3 (fast 2) $ sound "bd sd ~ cp"

-- This saves you from having to match up ( and ) around a function's
-- final input. It doesn't work with anything other than the final
-- input, so unfortunately this _doesn't_ work

d1 $ every 3 $ fast 2 $ sound "bd sd ~ cp"

-- The above would work out 'fast 2 $ sound "bd sd ~ cp"' first, and
-- would then try to pass that to 'every' as its second parameter,
-- which doesn't make sense to tidal, so it returns an error.

-- Note that when Tidal makes an error, if there was already a
-- pattern running, it will keep that going. If you're live coding
-- in front of an audience, you probably don't want an error to
-- result in silence!

d1 $ jux rev $ speed "<1 0.5 0.75>(<3 5>,8)" # sound "bev" # cut 1
  # room 0.4 # sz 0.9 # gain 1.3

d2 $ jux rev $ sound "sax(3,8)" # legato 1 # n 3
  # note "<[9 7] 5 [9 12]>" # djf 0.7 # sz 0.4 # room 0.4

  setcps 0.6

  -- Hear it straight
  d1 $ splice 8 "0 1 2 3 4 5 6 7" $ sound "break:4"

  -- Now with a more messed-up pattern
  d1 $ splice 8 "6 1 [2 3] ~ 4 1 6*2 7" $ sound "break:4"

-- Try changing the cps to hear it at different speeds

-- Try manipulating the pattern of slices
d1 $ splice 8 (fast "1 [0.5 0.75]" "6 1 [2 3] ~ 4 1 6*2 7")
   $ sound "break:4"

-- Now try all the above with 'slice' instead of 'splice'.
-- Slice _doesn't_ do the pitching up/down thing to splice the
-- sound to the step.

-- Here I put six slices from a loop originally in 4/4, to create
-- a 3/4 waltz
d1 $ splice 8 ("0 1 2 3 4 5") $ sound "break:4" # gain 1.1
d2 $ sound "kick snare*2 clap:4" # speed 2

-- Let's take a nice break:
once $ sound "break:8"

-- We can use 'begin' and 'end' to only play part of the sound, in this
-- case the final quarter of it:
d1 $ sound "break:8*4" # begin 0.75 # end 1

-- We can also use 'unit "c"' to change the behaviour of 'speed' so it
-- changes the playback speed to match the cps
d1 $ sound "break:8" # speed 1 # unit "c" # begin 0.75 # end 1

-- Lets play four of those to fill the cycle
d1 $ sound "break:8*4" # speed 1 # unit "c" # begin 0.75 # end 1

-- Then play with the cps to hear it change, fitting the cps perfectly
setcps 0.8

-- Normally, I wouldn't use 'unit', 'begin' and 'end' by hand. Instead
-- I'd use splice / slice from the previous lesson, or 'chop' to cut
-- a sound into bits, and set the length of the loop in cycles with
-- 'loopAt'
d1 $ loopAt 2 $ chop 4 $ sound "break:8"

-- The above sounds pretty continuous, but it is chopped into four parts.
-- We can hear that by reversing the chopped up parts:
d1 $ loopAt 2 $ rev $ chop 4 $ sound "break:8"

-- If we slow the pattern we can hear each part separately:
d1 $ slow 2 $ loopAt 2 $ chop 4 $ sound "break:8"

-- Here's a different sample:
d1 $ slow 2 $ loopAt 2 $ chop 4 $ sound "break:9"

-- Now what happens if we put both breaks in the sequence?
d1 $ slow 2 $ loopAt 2 $ chop 4 $ sound "break:8 break:9"

-- With 'chop', it will play all the parts of break:8, followed by
-- all the parts of 'break:9'.

-- If we swap 'chop' for its friend 'striate', then parts from the
-- two breaks are instead interlaced:
d1 $ slow 2 $ loopAt 2 $ striate 4 $ sound "break:8 break:9"

-- Play with that striate value for fun:
d1 $ slow 2 $ loopAt 2 $ striate 32 $ sound "break:8 break:9"

-- If you use the *same* loop multiple times with striate, it kind
-- of stretches it:
d1 $ slow 4 $ loopAt 1 $ striate 4 $ sound "break:1*4"

-- Here's what that normally sounds like:
once $ sound "break:1"

-- 'bev' is an even longer sample..
d1 $ loopAt 16 $ striate 32 $ sound "bev"

d1 $ slow 4 $ jux rev $ loopAt 16 $ striate 128 $ sound "bev*4"

-- 'Continuous functions' provide different kinds of waveforms.
-- There's a nice graphic showing sine, square, triangle and sawtooth
-- waves here: https://en.wikipedia.org/wiki/Waveform

-- Here's what the sine waveform sounds like applied to sample playback
-- speed:
d1 $ sound "bd*32" # speed sine

-- and to panning:
d1 $ sound "bd*32" # pan sine

-- and to waveshape distortion (gets loud):
d1 $ sound "bd*32" # shape sine

-- You can manipulate continuous patterns just like other kinds of
-- patterns, for example slowing down:
d1 $ sound "bd*32" # shape (slow 2 sine)

-- The waveforms all move between 0 and 1. So at its lowest point, sine
-- will be 0, and at its highest point it will be 1. Having a value
-- near 0 can be problematic with 'speed', as you can end up with
-- sounds played very slowly that take a long time to complete.

-- To get around this you can add to the sine:
d1 $ sound "bd*32" # speed (sine + 0.5)

-- Or use the 'range' function:
d1 $ sound "bd*32" # speed (range 0.5 1.5 sine)

-- Lets listen to triangle, sawtooth and square waves:
d1 $ sound "bd*32" # speed (range 0.5 1.5 tri)

d1 $ sound "bd*32" # speed (range 0.5 1.5 saw)

d1 $ sound "bd*32" # speed (range 0.5 1.5 square)

-- What happens if you put the continuous pattern on the left?
-- Remember that with '#', the rhythmic structure comes from the
-- left. Try this:
d1 $ speed (range 0.5 1.5 sine) # sound "bd"

-- Silence! Why's that?
-- It's because continuous functions don't actually contain any
-- events. They have values which continually change, without
-- triggering anything.

-- If we want to trigger events in a continuous pattern, we have
-- to explicitly sample values from it. One way to do that is with
-- the 'segment' function:
d1 $ speed (segment 32 $ range 0.5 2.5 sine) # sound "bd"

-- The above samples 32 values per cycle, generating discrete
-- events from them.

-- Another way to do this is with 'binary' or 'boolean' patterns,
-- using the 'struct' function:
d1 $ speed (struct "t(3,8)" $ slow 2 $ range 0.5 2.5 sine)
  # sound "bd"

-- 't' stands for 'true'. So that euclidean rhythm is used to sample
-- events from the continuous sine function. We'll return to
-- binary patterns in another video.

-- You can also add or multiply continous patterns together:
d1 $ sound "bd*32" # speed (range 0.5 2.5 (sine + (slow 2 saw)))

d1 $ sound "bd*32" # speed (range 0.5 2.5 (sine * (slow 2 saw)))

-- I slowed the 'saw' down in the above patterns, so you end
-- up with a sine wave that rises in pitch over two cycles.

-- In Tidal, random functions are also often continous.
-- For example, rand works like sine, saw etc, but returns random
-- values:
d1 $ sound "bd(5,8)" # speed (range 1 3 rand)

-- Perlin is similar, but returns 'perlin noise'. In Tidal, this
-- means that the pattern smoothly transitions between random values,
-- every cycle:
d1 $ sound "bd(5,8)" # speed (range 1 3 perlin)

-- Lets try that with some reverb:
d1 $ sound "bd(7,16)"
   # room 0.7
   # sz (range 0.4 1 $ slow 4 perlin)

 -- Let's start with a look at the 'rand' waveform that we
 -- met in the last lesson:

 d1 $ n "1*8" # sound "drum"
   # speed (range 1 8 rand)

 -- The 'resetCycles' resets the cycle count to '0', as
 -- though you'd just started Tidal:
 resetCycles

 -- If you run resetCycles while the above pattern is running,
 -- you'll notice that you also reset the random stream. You
 -- will always get the same 'random' numbers every time you
 -- start or reset Tidal.

 -- You can apply rand to any numerical effect, but might have
 -- to adjust the range. For example with the low pass filter
 -- that cuts out frequencies higher than the given amount:
 d1 $ sound "drum:5(5,8,<0 4>)"
    # lpf (range 200 8000 rand)
    # lpq 0.2

 -- 'irand' is similar to 'rand', but creates integers, or
 -- whole numbers, from 0 up to (and not including) the given
 -- number. This is particularly useful for the 'n' and
 -- 'note' controls:

 d1 $ sound "rash(5,8)" # n (irand 32)
    # room 0.3 # sz 0.5

 -- There are a couple of ways of doing random things in the
 -- mininotation too. To randomly choose between subsequences,
 -- put a | (vertical bar) between them

 -- The second step in this sequence is a randomly pick from
 -- four subsequences:
 d1 $ n "0 [0|1*3|2*8|3 4 5] 2 3" # sound "cpu"
    # speed 1.5

 -- Also, ? randomly 'drops' an event. In the following the
 -- second step has a 50-50 chance of being played.
 d1 $ sound "kick clap? kick snare"
   # delay 0.3 # delaytime (1/3) # delayfb 0.8 # speed 1.5

 -- (I've added some echo delay to make it sound cool. Delay is the
 -- amount of sound to be delayed, delaytime is the length of the
 -- echo, delayfb is the feedback of the delay into itself)

 -- You can adjust the probability of ? working with a decimal
 -- (floating point) number. For example, to have an 80% chance
 -- of dropping that clap (and therefore 20% chance of playing
 -- it)
 d1 $ sound "kick clap?0.8 kick snare"
   # speed 1.5

 -- If you apply ? to a subsequence, it'll work individually
 -- on each value in the subsequence
 d1 $ sound "kick [clap:4 off clap:5]? kick snare"
   # speed 1.5

 d1 $ sound "bd*8? clap:4"

 -- Ok, onward to functions, starting with scramble. scramble
 -- takes a number, which is the number of parts to equally
 -- divide a pattern into. It'll then play those parts at
 -- random.
 d1 $ scramble 4 $ n "0 1 2 3 4 5 6 7" # sound "arpy"
    # room 0.3 # sz 0.8

 -- The above is divided into four parts, and there are
 -- eight events in them, so they are played in pairs. This
 -- means that 0 is always followed by 1, 2 is always followed
 -- by 3, and so on.

 -- shuffle takes the same parameters as scramble, and sounds
 -- very similar. Can you hear the difference?
 d1 $ shuffle 4 $ n "0 1 2 3 4 5 6 7" # sound "arpy"
   # room 0.3 # sz 0.8

 -- Whereas scramble picks part at random, shuffle plays the
 -- parts in random order. The difference is that with shuffle,
 -- every cycle, you'll hear each part exactly once. With
 -- scramble, there's a (small) chance that you'll hear only
 -- one part, played four times.


 -- You can maybe hear this better if you play a clap at the
 -- same time, to mark the start of the cycle. Then you can
 -- hear that parts aren't repeating within the cycle.
 d1 $ shuffle 4 $ n "0 1 2 3 4 5 6 7" # sound "arpy"
   # room 0.3 # sz 0.8

 d2 $ sound "clap"

 -- The "choose" function is for when you want to pick between
 -- single values. It produces a continuous stream, with no
 -- structure, so the following won't produce any events:
 d1 $ sound (choose ["bd", "arpy", "snare"])

 -- You'll need to provide some structure, with a function like
 -- 'segment', which in this case picks 8 values per cycle:
 d1 $ sound (segment 8 $ choose ["bd", "arpy", "snare"])

 -- Or 'struct', which picks values according to a binary pattern:
 d1 $ sound (struct "t t ~ t" $ choose ["bd", "arpy", "kick"])

 d1 $ sound (struct "t(5,8)" $ choose ["bd", "arpy", "kick"])

 -- Or by combining it with a pattern that *does* have structure:
 d1 $ squiz "0*2 4 2 5 0 6*2 4 7"
   # sound (choose ["bd", "arpy", "kick"])

 -- Another 'gotcha' - the parameters to choose are a list of values,
 -- *not*, patterns, so you can't normally use mininotation there.

 -- This *won't* work.
 d1 $ squiz "0*2 4 2 5 0 6*2 4 7"
   # sound (choose ["bd*5", "arpy*2", "kick clap"])

 -- I'll try to fix this in a future version of tidal! There is a
 -- workaround, which is to use the 'innerJoin' function. Then you
 -- can choose between patterns:
 d1 $ squiz "0*2 4 2 5 0 6*2 4 7"
   # sound (innerJoin $ choose ["bd*5", "arpy*2", "kick clap"])

 -- You can use choose with any parameter.

 -- For example:
 d1 $ sound "clap:4(3,8)"
   # speed (choose [2,5,0.5])

 -- The following example is a bit different to the above, because
 -- a new value is chosen only once per cycle:
 d1 $ sound "clap:4(3,8)"
   # speed "[2|5|0.5]"

 -- You could get the same behaviour from choose with 'segment'ing it
 -- by a cycle:
 d1 $ sound "clap:4(3,8)"
   # speed (segment 1 $ choose [2,5,0.5])

 -- The 'wchoose' function is like 'choose', but you can give
 -- a 'weighting' for each possibility. So something with a weighting
 -- of '4' would be twice as likely to be chosen as one with a weighting
 -- of '2', for example:
 d1 $ sound "clap*4" # speed (wchoose [(2, 4), (-2, 2)])

 -- The above claps will play either with a speed of '2' , or '-2'.
 -- You can hear that negative speeds cause sounds to play backwards!
 -- '2' has a weighting of '4', and '-2' has a weighting of
 -- '2', so is half as likely to play.

 -- Here I've weighted things so you get a lot of kicks, occasional
 -- claps, and rarer snares:
 d1 $ squiz "1 4*8 8*2 0*3"
   # sound (wchoose [("bd", 8), ("snare", 0.5), ("clap", 1)])

 -- Ok one more thing! In Tidal, randomness is "deterministic". At
 -- a certain cycle time, you will always get the same number. We
 -- saw this at the start of the lesson, with resetCycles. That
 -- resets the cycle count, as if you just started Tidal up. You
 -- can then hear that the 'random' numbers are the same.

 -- This can result in unexpected results.
 -- Listen to this:
 d1 $ sound "clap*2" # speed (range 0.1 2 rand) # pan rand

 -- You can hear that on the left speaker, the 'speed' of the
 -- sound is always low, and when it pans to the right, it's
 -- always high. Strange! This is because the same 'random'
 -- number stream is used for both the speed and the pan, so
 -- they get the same numbers, and seem to interact.

 -- This can be nice! But if you don't want this effect, you can
 -- avoid it by manipulating the timeline of one of the random
 -- patterns. For example:
 d1 $ sound "clap*2" # speed (range 0.1 2 rand)
   # pan (slow 1.001 rand)

 -- I only slowed that 'rand' down by a tiny amount, but that's
 -- enough to end up with totally different numbers.. So now
 -- you're as likely to get lower speeds on the left as on the right.


 -- randcat

-- randcat is a variant of cat, which we haven't actually looked at
-- yet, so lets start with that..
d1 $ sound (cat ["kick snare:4 [~ kick] snare:5", "kick snare:4 . hc(5,8)"])

-- So you can hear that cat 'concatenates' patterns - it plays them
-- one after the other, in order.

-- randcat on the other hand, plays them in random order:
d1 $ sound (randcat ["kick snare:4 [~ kick] snare:5", "kick snare:4 . hc(5,8)"])

-- You can give it as many patterns to choose from as you like:
d1 $ sound (randcat ["kick snare:4 [~ kick] snare:5",
                     "kick snare:4 . hc(5,8)",
                     "snare:3(9,16)"
                    ]
           )

-- You can use it to randomise control patterns other than sound,
-- e.g. the vowel effect:
d1 $ vowel (randcat ["a e*2 i o", "e o u", "o*8"])
   # sound ("kick snare:4 clap:4")


-- wrandcat is to randcat, what wchoose is to choose. That is,
-- You can give the choices relative probabilities:
d1 $ sound (wrandcat [("bd sn:4(3,8)", 1),
                      ("arpy clap", 0.5),
                      ("cpu(5,8)", 0.25)
                     ]
           )

-- stripe is a weird one. Lets start with a rhythm with the
-- cpu2 samples:
d1 $ n "0 4*2 ~ 4 2 4 5 ~" # sound "cpu2"
  # squiz 2

-- 'fast 2' would squeeze that into two cycles:
d1 $ fast 2 $ n "0 4*2 ~ 4 2 4 5 ~" # sound "cpu2"
  # squiz 2

-- stripe is similar, but the cycles are random durations,
-- although still fit the cycle:
d1 $ stripe 2 $ n "0 4*2 ~ 4 2 4 5 ~" # sound "cpu2"
  # squiz 2

-- It sounds random, but against a straight clap, you can hear
-- every other repetition still perfectly aligns with the cycle:
d2 $ sound "clap:4"

-- degrade - remember the ? mininotation modifier in the previous
-- video? It drops events at random:
d1 $ sound "bd*8?"

-- Degrade is a function that does the same:
d1 $ degrade $ sound "bd*8"

-- Just like this:
d1 $ sound "bd*8?0.6"

-- You can specify a probability, by using 'degradeBy'. E.g.,
-- to give each event a 60% chance of being 'lost':
d1 $ degradeBy 0.6 $ sound "bd*8"

-- 'sometimes' applies a function to a pattern, but only sometimes.
-- lets hurry this rhythm, but only sometimes:
d1 $ sometimes (hurry 2) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"

-- Here's the original, which sounds pretty boring in comparison:
d1 $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"

-- You can use it to apply effects as well.
d1 $ sometimes (# crush 4) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"

-- There's also a 'sometimesBy' variant, for specifying a
-- probability:
d1 $ sometimesBy 0.3 (# crush 4) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"

-- There's some aliases for different probabilities:

{-
sometimes = sometimesBy 0.5
often = sometimesBy 0.75
rarely = sometimesBy 0.25
almostNever = sometimesBy 0.1
almostAlways = sometimesBy 0.9
-}

-- So you can do this:
d1 $ rarely (# crush 4) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"

-- somecycles is similar to sometimes, but works on whole
-- cycles at a time, rather than individual events:
d1 $ somecycles (hurry 2) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"
  # speed 1.5

-- Again, there's a 'somecyclesBy' variant for being specific
-- about that probability. To apply the squiz, 90% of the time:
d1 $ somecyclesBy 0.9 (# squiz 4) $ n "0 ~ 3 1 5 2 ~ 5" # sound "cpu"
  # speed 1.5

-- randslice is a bit like 'slice' that we met a couple of lessons
-- ago:
d1 $ slice 4 "0 1 2 3" $ sound "break:8"

-- Instead of taking a pattern of slices though, it picks slices at
-- random. So to play a random quarter of this break:
d1 $ randslice 4 $ sound "break:8"

-- We can use 'loopAt' to fit them to a cycle, just like we saw before
-- with 'chop' and 'striate':
d1 $ loopAt 1 $ randslice 4 $ sound "break:8*4"

-- We could also do the same sort of thing by giving 'slice' or 'splice'
-- a random pattern:
d1 $ splice 4 (segment 4 $ irand 4) $ sound "break:8"


-- If you 'run' a pattern by itself, without a 'd1' or so, then Tidal
-- will do its best at telling you what's in the first cycle. For
-- example:

note "3"

-- gives:

-- (0>1)|note: 3.0f

-- 0>1 tells you it's an event that starts at position 0 (the start of
-- the first cycle) and lasts up to 1 (the start of the next cycle).
-- note is the name of the 'control' or 'effect' 3.0f is the value
-- ('f' tells you that it's a floating point, decimal number).

note "3 ~ 5"

-- the above gives two events:

-- (0>⅓)|note: 3.0f
-- (⅔>1)|note: 5.0f

-- We can listen to them:

d1 $ note "3 ~ 5" # s "superpiano"

-- Great notes!

-- (.. if you don't hear any, you probably need to install "sc3plugins".)

-- Tidal can also understand note names, and turn them into numbers
-- for you.

-- For example 'c' is the same as '0'

note "c"

-- This:

note "a b c d e f g"

-- is the same as:

note "9 11 0 2 4 5 7"

-- What happened to 1, 3, 6, 8, and 10?
-- You can get to them by adding 's' for 'sharp', to add 1 to a note:

note "cs ds fs gs as"

-- or by using 'f' for 'flat' to subtract 1:

note "df ef gf af bf"

-- In theory, you can get to them all via really sharp 'c'
-- notes. These two notes are identical:
d1 $ note "csssssss g" # s "superpiano"

-- In practice, that surely doesn't make a lot of sense.

-- Normally, there are twelve notes in an octave. The default octave
-- is 5, you can pick notes from other octaves by adding a different
-- number:
note "c5 c6 c4 c6"

-- Lets have a listen
d1 $ note "c5 c6 c4 c6" # s "superpiano"

-- Lets think about the difference between 'note', 'n', synths and
-- samples.

-- There is no folder of samples called 'superpiano', the sounds you
-- hear are being synthesised on-the-fly.

-- With synths, you can use either 'note' or 'n' to specify notes,
-- they mean the same thing.

d1 $ n "c a f e" # s "superpiano"

d1 $ note "c a f e" # s "superpiano"

-- For samples, they mean something different. 'n' chooses a sample,
-- 'note' plays it at a different speed, corresponding to a note.

-- Different sounds:
d1 $ n "0 1" # sound "dsynth"

-- Different notes:
d1 $ note "0 1" # sound "dsynth"

-- If you pick a high note, then you'll notice the sound is a lot
-- shorter, because it's making it higher by playing it faster.
d1 $ note "0 24" # sound "dsynth"

-- You might feel that's not good, because it doesn't sound as natural
-- as a synthesiser
-- You might feel that's great, because nature is a myth and this is
-- how old school 'tracker' music from early rave music and the
-- demoscene works
-- You might change your mind on different days

-- You can still use note names in mininotation:
d1 $ note "c a f e" # sound "dsynth"

-- (Actually you can use do this in any control/effect pattern that
-- expects a number.. Tidal just treats them as numbers)

-- This dsynth sample is in 'c'. If it wasn't, the notes would
-- probably sound out of tune with another synth or samplebank.

-- The 'dbass' sample has three bass sounds, again in 'c', of
-- different lengths.  So it makes sense to use *both* 'note' and 'n'
-- together, to pattern both the pitch and the sample that's used:
d1 $ note "c a f e" # sound "dbass" # n "<0 1 2>"

-- The 'rash' samplebank is organised differently.. There's a load of
-- samples, one for each note of 6 octaves. There's 12 notes in an
-- octave, so that's 72 samples. (actually there's 73, there's an
-- extra one note-084.wav which you could delete..) I sampled these
-- from my lovely Roland JV1080 synth.

-- So you can play notes as numbers using the 'n' instead of the
-- 'note' pattern. This sounds a bit more 'natural' than pitching them
-- up with 'note'.
d1 $ n "20 50" # sound "rash"

-- You can still use note names, but whereas for synths '0' is *middle*
-- c, with these samples that's right at the *bottom* of the scale.
d1 $ n "c a f e" # sound "rash"

-- So in this case you'll want to pick a higher octave
d1 $ n "c7 a7 f8 e7" # sound "rash"

-- I tend to add a few octaves like this:
d1 $ n "c a f e" # sound "rash"
  |+ n 24

-- Adding notes together is fun :
d1 $ n "c a f e" # sound "rash"
  |+ n 24
  |+ n "<0 2 7 12>"

-- You can also do it this way, adding together number patterns
-- 'inside' a single control pattern
d1 $ n ("c a f e" |+ 24 |+ "<0 2 7 12>")
  # sound "rash"

-- There's also an 'octave' control to jump up/down in twelves:
d1 $ note "c a f e" # sound "superpiano"
  # octave "<4 6 3>"



  -- Ok chords! We can play a 'major' chord like this:

  d1 $ n "'maj" # sound "supermandolin"
    # legato 2 # gain 1.4

  -- The default is c major, you can choose others like this, e.g. to
  -- play c then e major:
  d1 $ n "c'maj e'maj" # sound "supermandolin"
    # legato 2 # gain 1.4

  -- Karaoke (algoraoke) time
  -- Lets take the chord from a well known song:
  -- https://ukutabs.com/r/radiohead/creep/

  d1 $ n "<g'maj b'maj c'maj c'min>" # s "supermandolin"
    # room 0.6 # sz 0.9

  -- and strum it a bit with struct:
  d1 $ qtrigger 1 $ jux ((|- n "12") . rev) $ struct "t(5,8,<0 4>)" $ n "<g'maj b'maj c'maj c'min>" # s "supermandolin"
    # room 0.6 # sz 0.9

  -- You can get a list of all the chords like this:
  import Sound.Tidal.Chords

  chordList

  -- Try some out:
  d1 $ n "c'sevenFlat9 a'm9sharp5" # sound "supermandolin"

  -- Here's the raw data:
  chordTable

  -- Again, this all ends up being turned into plain note numbers. These
  -- two patterns are the same:
  d1 $ n "c'sevenFlat9 a'm9sharp5" # sound "supermandolin"

  d1 $ n "[0,4,7,10,13] [9,10,23]" # sound "supermandolin"

  -- You can say how many notes you want in a chord, with another ' and
  -- the number of notes you want.

  -- If you ask for more notes than exist in the basic chord, it will go
  -- up the octaves to find more notes, sounding more and more impressive:
  d1 $ n "c'maj'4" # s "superpiano"
  d1 $ n "c'maj'8" # s "superpiano"
  d1 $ n "c'maj'12" # s "superpiano"

  -- This is clearer when we start doing.. ARPEGGIOS

  -- These are 'broken' chords, where instead of playing the notes at
  -- once, they're played one after another:
  d1 $ arpeggiate $ n "c'maj" # s "superpiano"

  -- The arpeggio happens within the 'step' that the chord occupies:
  d1 $ arpeggiate $ n "c'maj e'min7" # s "superpiano"

  -- Above, you can hear major chords have three notes, and minor 7
  -- chords have four. You can modify that with ' so they have the same
  -- number, if you want:
  d1 $ arpeggiate $ n "c'maj'4 e'min7'4" # s "superpiano"

  -- "arpeggiate" has a shorter, but more flexible cousin "arp", that
  -- allows you to specify a different way of breaking up the chord:
  d1 $ arp "updown thumbup" $ n "<c'maj'4 e'min7'4>" # s "superpiano"

  -- Here's the list of currently available arp styles to explore:
  -- up, down, updown, downup, converge, diverge, disconverge, pinkyup,
  -- pinkyupdown, thumbup thumbupdown

  -- Lots of fun
  d1 $ jux rev $ arp "<updown thumbup pinkyupdown converge diverge>"
    $ n "<c4'maj'6 e4'min7'8 g5'maj'5 a5'maj'4>" # s "superpiano"
    # room 0.3 # sz 0.7



    -- Let's start with two notes:
    d1 $ n "c e" # sound "supermandolin"

    -- What does 'off' do? Switch between the above and below versions to hear
    -- the difference.
    d1 $ off 0.25 (# crush 4) $ n "c e" # sound "supermandolin"

    -- You can hear that the original two notes are untouched, but there is
    -- something else added.

    -- 'off' takes three inputs; a number, a function and a pattern.
    -- What it does is leave the original pattern as is, but adds a copy of
    -- it on top. That copy is offset in time by the number given in the first
    -- input - the number. The copy also has the function applied to it.
    -- So we end up with a version of the pattern that 'follows' the original
    -- in time, and is transformed. In this case, it is distorted.

    -- Instead of using the bitcrush effect, lets add to the 'n' note, instead.
    d1 $ off "0.25" (|+ n 7) $ n "c e" # sound "supermandolin"

    -- Now we hear a simple 'canon' - it sounds like one voice following another.

    -- We can swap '0.25' for the shorthand 'q', which stands for a *q*uarter of a
    -- cycle.
    d1 $ off "q" (|+ n 7) $ n "c e" # sound "supermandolin"

    -- Lets change that for 'e', which stands for an eighth of a cycle.
    d1 $ off "e" (|+ n 7) $ n "c e" # sound "supermandolin"

    -- Here's the current list of shorthands available:
    -- w = 1 (whole)
    -- h = 0.5 (half)
    -- q = 0.25 (quarter)
    -- e = 0.125 (eighth)
    -- s = 0.0624 (sixteenth)
    -- t = 1/3 (third)
    -- f = 0.2 (fifth)

    -- You can have multiples of these shorthands by prefixing them with a
    -- number, for example:
    d1 $ off "2f" (|+ n 7) $ n "c a f e" # sound "supermandolin"

    -- For a 32nd, you could do 0.5s:
    d1 $ off "0.5s" (|+ n 7) $ n "c a f e" # sound "supermandolin"

    -- Let's try with a more complex pattern:
    d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
      # sound "supermandolin"

    -- The notes are getting very short now, to match the shorter 'step' sizes
    -- within this denser pattern. To make them proportionally longer we can
    -- use legato, for example to make them all twice as long:
    d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
      # sound "supermandolin"
      # legato 2

    -- Or alternatively we can use sustain for a duration in seconds:
    d1 $ off "e" (|+ n 7) $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
      # sound "supermandolin"
      # sustain 0.75

    -- We can pattern the 'n' of the transformed version of the pattern:
    d1 $ off "e" (|+ n "<7 12 -5>") $ n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
      # sound "supermandolin"
      # sustain 0.75

    -- In the above the 7 - 12 - -5 pattern repeats every third cycle, and the
    -- c a f e one repeats every two cycles (due to the slow 2). The combination
    -- of (or interference between) them repeats lasts six cycles.

    -- Lets add another 'off', this time offset by a sixteenth of a cycle, and
    -- dropping the octave.
    d1 $ off "s" (|+ n (-12)) $ off "e" (|+ n "<7 12 -5>") $
     n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
     # sound "supermandolin"
     # sustain 0.75

    -- Note that negative numbers have to be in parenthesis, otherwise Haskell
    -- gets confused and things you're trying to do a subtraction!

    -- This isn't the case in the mininotation, so an alternative is to put
    -- all negative numbers in double quotes:
    d1 $ off "s" (|+ n "-12") $ off "e" (|+ n "<7 12 -5>") $
     n (slow 2 "c(3,8) a(3,8) f(5,8) e*2")
     # sound "supermandolin"
     # sustain 0.75

    -- The same principles can be applied to percussion, for example:
    d1 $ off "<s q e>" (# squiz 2) $ n "{0 1 [~ 2] 3*2, 5 ~ 3 6 4}"
      # sound "cpu2"
      # sustain 0.75

    -- Notice the offset is patterned in the above, so the 'following'
    -- pattern shifts forwards and backwards.


    -- The 'arpy' folder contains sounds sampled using a pentatonic
    -- 'ritusen' scale, starting with 'c'. In this scale there are five
    -- notes per octave.  So these are the same notes:
    d1 $ n "0 5" # sound "arpy"

    d2 $ n "0 12" # sound "superpiano"

    -- Pentatonic scales like this are nice to work with because they all
    -- sound good together. So if we add a random note to a melody, it
    -- always sounds 'good':

    d1 $ n ("0 [7 2] 3 2" |+ irand 3) # sound "arpy"

    -- This isn't really the case on the usual twelve-tone "equal
    -- temperament" (12-TET) scale:
    d1 $ n ("0 [7 2] 3 2" |+ (irand 3)) # sound "superpiano"

    -- 12-TET is the scale that pianos etc are normally tuned to in the west.

    -- To use a different scale, we can use the "scale" function for converting
    -- numbers from a different scale to 12-TET.
    d1 $ n (scale "ritusen" $ "0 [7 2] 3 2" |+ (irand 3))
      # sound "superpiano"

    -- There's quite a few available:
    scaleList

    -- It's fun to use waveforms to pick notes from a scale. For example,
    -- use a smooth sinewave to select notes from a minor scale:
    d1 $ segment 16 $ n (scale "minor"
                         $ floor <$> (range 0 14 sine)
                        )
      # sound "supersaw"
      # legato 0.5
      # lpf 1000 # lpq 0.1

    -- Remember that waveforms don't have structure, so don't produce
    -- events until you use something like 'segment', which in the example
    -- above picks 16 notes per cycle.

    -- There's also a complication that waveforms produce 'floating point'
    -- decimal numbers, but scale only accepts 'integers' - whole numbers.
    -- The 'floor <$>' bit converts from decimal to whole numbers.  The
    -- "range 0 14" bit converts from the usual range of 0 to 1 to the
    -- given range of 0 to 14.

    -- We can make this more exciting by patterning the range:
    d1 $ segment 16 $ n (scale "minor"
                         $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
                        )
      # sound "supersaw"
      # legato 0.5
      # lpf 1000 # lpq 0.1

    -- And maybe even more exciting by using 'struct' to pattern the
    -- rhythm using Euclidean syntax.. Taking the opportunity to pattern
    -- the lpf (low pass filter) as well:
    d1 $ struct "t(<9 7>,16)"
      $ n (scale "minor"
            $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
          )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1


    -- Using scales in this way allows us to play with movement while
    -- still making tunes that make 'sense'. Here I add together
    -- waveforms to create some longer-form movement:
    d1 $ segment 16 $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- Back with the struct:
    d1 $ struct "t(<9 7>,16)" $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- And with an 'off' going up an octave:
    d1 $ off 0.25 (|+ n 12) $ struct "t(<9 7>,16)" $ segment 16 $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- Note that in the above the 'off' is outside of the 'scale'
    -- function, So we're back in 12-TET land, so add '12' to go up an
    -- octave, rather than the number of notes in the minor scale (7)


    -- Composing patterns together

  -- We've already looked at different ways of composing patterns
  -- together. Something as simple as this is a composition:

  d1 $ fast "1 2 3 4" $ sound "lt mt ht bd*2"

  -- Not a super interesting one, but it composes together a pattern of
  -- densities, and a pattern of sounds, to create a new pattern that is
  -- more than the sum of its parts.

  -- In this lesson though we're going to look at ways to compose what
  -- you could call 'independent' patterns, where one isn't used to
  -- manipulate the other.

  -- Tidal is often used in live situations, but there are some
  -- functions that help you assemble multiple patterns into something
  -- like a complete 'piece', such as a structured four-minute track.

  -- Before we get to that, lets look at some extra-simple ways of
  -- composing patterns together.. as they can be surprisingly useful

  -- First, there's `overlay` that simply plays the two given patterns
  -- at the same time:
  d1 $ overlay (fast "1 2 3 4" $ sound "lt mt ht ~")
               (sound "clap:4(3,8)" # speed 2)

  -- Similar to this is `stack`, which lets you overlay any number of
  -- patterns on top of each other. People tend to use this rather than
  -- `overlay`, as it's more flexible:
  d1 $ stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
              (sound "clap:4(3,8)" # speed 2),
              sound "[kick:5(5,8), snare:3(7,16,3)]"
             ]

  -- The above composes a list of three patterns together. You can see that
  -- a list is given using square brackets ('[' and ']'), with the patterns
  -- in the list separated by commas (','). You have to remember *not* to
  -- put a comma at the end of the list, only between the elements.

  -- The above might not seem too useful, as you could do the same with
  -- separate patterns. This sounds exactly the same as the above:
  d1 $ fast "1 2 3 4" $ sound "lt mt ht ~"
  d2 $ sound "clap:4(3,8)" # speed 2
  d3 $ sound "[kick:5(5,8), snare:3(7,16,3)]"

  -- Remember though that stack combines everything into a single
  -- pattern. This is useful as you can manipulate all those patterns as
  -- one. For example:
  d1 $ chunk 4 (hurry 2) $
    stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
           (sound "clap:4(3,8)" # speed 2),
           sound "[kick:5(5,8), snare:3(7,16,3)]"
          ]

  -- Or adding a parameter that applies to the whole stack:
  d1 $ stack [(fast "1 2 3 4" $ sound "lt mt ht ~"),
              (sound "clap:4(3,8)" # speed 2),
              sound "[kick:5(5,8), snare:3(7,16,3)]"
             ] # squiz "<0 2>"

  -- So `overlay` and `stack` stack things up, so that they happen at
  -- the same time. Howabout sticking things together over time, so they
  -- happen one after another?

  -- Like overlay and stack, there is one function, 'append' for
  -- composing two patterns together, and another, 'cat' for composing a
  -- list of patterns together.

  -- For two patterns:
  d1 $ append (fast "1 2 3 4" $ sound "lt mt ht ~")
              (sound "clap:4(3,8)" # speed 2)

  -- For a list of patterns:
  d1 $ cat [fast "1 2 3 4" $ sound "lt mt ht ~",
            sound "clap:4(3,8)" # speed 2,
            sound "[kick:5(5,8), snare:3(7,16,3)]"
           ]

  -- Again, you'll see `cat` used more often than `append`.

  -- `append` and `cat` maintain the original 'density' of the patterns,
  -- taking one cycle per cycle.

  -- There are variants `fastappend` and `fastcat`, that take a cycle
  -- from each of the patterns, and squash them all into a single cycle:

  -- For two patterns:
  d1 $ fastappend (fast "1 2 3 4" $ sound "lt mt ht ~")
    (sound "clap:4(3,8)" # speed 2)

  -- For a list of patterns:
  d1 $ fastcat [fast "1 2 3 4" $ sound "lt mt ht ~",
                sound "clap:4(3,8)" # speed 2,
                sound "[kick:5(5,8), snare:3(7,16,3)]"
               ]

  -- That's fine, but what if you don't want to loop between patterns a
  -- cycle at a time, but have something between a `stack` and a `cat`,
  -- where you can have the patterns overlap? `seqPLoop` is one answer.

  -- With `seqPLoop`, you say when each pattern starts and stops.
  -- Lets first emulate the `cat` from earlier, by having each
  -- pattern last one cycle.
  d1 $ seqPLoop [(0, 1, fast "1 2 3 4" $ sound "lt mt ht ~"),
                 (1, 2, sound "clap:4(3,8)" # speed 2),
                 (2, 3, sound "[kick:5(5,8), snare:3(7,16,3)]")
                ]

  -- Now let's adjust the starts and stops, so the first two overlap by
  -- a pattern, then there's a gap of a cycle before the last one plays:
  d1 $ seqPLoop [(0, 2, fast "1 2 3 4" $ sound "lt mt ht ~"),
                 (1, 3, sound "clap:4(3,8)" # speed 2),
                 (5, 6, sound "[kick:5(5,8), snare:3(7,16,3)]")
                ]

  -- If you want to use the same pattern more than once, you can give it a name
  --, like this:
  let florence = fast "1 2 3 4" $ sound "lt mt ht ~"
  in
  d1 $ seqPLoop [(0, 2, florence),
                 (1, 3, sound "clap:4(3,8)" # speed 2),
                 (3, 4, sound "[kick:5(5,8), snare:3(7,16,3)]"),
                 (3, 5, florence # coarse 5)
                ]

  -- If you don't want the pattern sequence to loop, then use
  -- seqP. You'll need to use something like `qtrigger`, so it starts
  -- from cycle 0
  d1 $ qtrigger 1 $ seqP [(0, 2, fast "1 2 3 4" $ sound "lt mt ht ~"),
                          (1, 3, sound "clap:4(3,8)" # speed 2),
                          (5, 6, sound "[kick:5(5,8), snare:3(7,16,3)]")
                         ]

 -- Composing functions together

 -- Lets say you wanted to both chop up, _and_ reverse this pattern,
 -- every 3 cycles.
 d1 $ sound "bd [~ sd] bd sd" # squiz 2

 -- You could do it like this:
 d1 $ every 3 (rev) $ every 3 (chop 8) $
   sound "bd [~ sd] bd sd" # squiz 2

 -- That works, but is a bit fiddly. This is where the `.` operator
 -- comes in handy, by turning two functions into one:
 d1 $ every 3 (rev . chop 8) $
   sound "bd [~ sd] bd sd" # squiz 2

 -- That works the same, but with less typing, good!

 -- You can just think of the `.` as piping together two functions
 -- into one.

 -- But technically speaking:, the `.` will take the input, pass it into the
 -- function on the right, take the output from _that_ function, pass
 -- it to the function on the left, and finally return the return of
 -- _that_ function.

 -- You can keep piping in more functions, if you want:
 d1 $ every 3 (rev . chop 8 . fast 2) $
   sound "bd [~ sd] bd sd" # squiz 2

 -- You can also add in effects:
 d1 $ every 3 ((# room 0.7) . rev . chop 8 . fast 2) $
   sound "bd [~ sd] bd sd" # squiz 2

 Have fun!


 d1 $ ur 16 "[bdsd, ~ claps, ~ [bass bass:crunch] ~ bass]"
   [("bdsd", sound "bd [~ sd] bd sd" # squiz 2),
    ("claps", sound "clap:4*2 clap:4*3"
      # delay 0.8 # dt "t" # dfb 0.4
      # orbit 4 # speed 4
    ),
    ("bass", struct "t(3,8)" $ sound "dbass" # shape 0.7 # speed "[1, ~ 2]")
   ]
   [("crunch", (# crush 3))
   ]

   -- SHIFTING TIME

   -- Lets start with a rhythm:
   d1 $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"

   -- That's repeating nicely. Keep it running, then run this:
   d1 $ 0.25 <~ (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2")

   -- If you switch between them, you can hear the pattern is shifting in
   -- time. The `0.25` means it's shifting by a quarter of a cycle.

   -- You only hear any difference between them at the point where you
   -- switch to the other one. You're jumping forward / backward in time,
   -- but once you're there, nothing has changed. (!)

   -- Ok, time travel is difficult to talk about.

   -- Lets visualise this, compare these two:
   drawLine "a b c d"

   drawLine $ 0.25 <~ "a b c d"

   -- You can see the a b c d sequence is the same, but in the latter
   -- case, the cycle begins on the 'b'.

   -- So '<~' has moved us _forward_ into the future. So shouldn't it be
   -- '~>', rather than '<~'?? Well, we might have moved into the future,
   -- but it's all relative - from the perspective of the pattern, it's
   -- moved backwards into the past. Furthermore, while we like to think
   -- about us moving forwards into the future, from the perspective of
   -- the future, it's moving backwards into the past. Furthermore
   -- different human cultures think about time in different ways.

   -- Anyway, '~>' does indeed exist, compare these two:

   drawLine $ 0.25 <~ "a b c d"

   drawLine $ 0.25 ~> "a b c d"

   -- Time is most interesting if you keep jumping around
   -- For example jump every 3 cycles:
   d1 $ every 3 (0.25 <~) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"
     # crush 4

   -- Jumping in the other direction has quite a different feel:
   d1 $ every 3 (0.25 ~>) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2"
     # crush 4

   -- You can also use a pattern for the time shift amount:
   d1 $ "<0 0.25 0.75>" ~>
     (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]" # sound "cpu2" # crush 4)

   -- Even with this straightforward shifting, things quickly start
   -- sounding 'random', until your ears lock on to the longer loop..

   -- SIDETRACK - a note on syntax..

   -- Unfortunately this use of the dollar *doesn't work*:
   d1 $ "<0 0.25 0.75>" ~> $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
     # sound "cpu2" # crush 4

   -- This is because like all operators, you can't use a dollar to group
   -- together a pattern to send to `~>` in this way. haskell gets
   -- confused about seeing two operators ('$' and '~>') next to each
   -- other.

   -- So you have to use parenthesis:
   d1 $ "<0 0.25 0.75>" ~> (n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
     # sound "cpu2" # crush 4)

   -- Or another way around this is to wrap the *operator* in
   -- parenthesis, then you can use it like a normal function:
   d1 $ (~>) "<0 0.25 0.75>" $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
     # sound "cpu2" # crush 4

   -- Or wrap the first input and the operator in parenthesis:
   d1 $ ("<0 0.25 0.75>" ~>) $ n "[0 [1 0] 6*2 [3 4*2], 8(5,8)]"
     # sound "cpu2" # crush 4

   -- This all works nicely with chopped-up loops:
   d1 $ every 2 ("e" <~) $ every 3 (0.25 <~) $
     loopAt 1 $ chop 8 $ sound "break:8"

     -- Binary patterns

     -- The patterns you send to SuperDirt tend to contain values of type
     -- String (for words), Double (for decimal numbers) or Int (for whole
     -- numbers). One pattern type you probably won't send to SuperDirt is
     -- of type Bool - short for Boolean.

     -- Boolean values can be either True or False. You've probably seen
     -- then used with with 'struct', e.g.:

     d1 $ struct "t f t t f t f f" $ sound "snare:4"

     -- 'struct' provides structure for the pattern on the right; whenever
     -- there's a 't' (i.e., a true value) in the boolean pattern, the
     -- snare fires.

     -- It works with euclidean syntax too:
     d1 $ struct "t(3,8)" $ sound "snare:4"

     -- The above creates a new pattern with three events per cycle,
     -- according to a Euclidean pattern.

     -- Lets have a look at that euclidean pattern:
     drawLine $ struct "t(3,8)" "a"

     -- So what do you think would happen if you changed that 't' (for
     -- true) for an 'f' (for false)? Lets try:
     drawLine $ struct "f(3,8)" "a"

     -- Lets listen to that structure too:
     d1 $ struct "f(3,8)" $ sound "snare:4"

     -- You can see and hear that the *inverse* of the Euclidean pattern is
     -- played. What was true, is now false, and vice-versa.. It's the
     -- 'empty' steps which get the true values, and which we end up
     -- hearing.

     -- This is clearer if we play a t(3,8) against an inverted f(3,8):
     d1 $ stack [struct "t(3,8)" $ sound "kick:4",
                 struct "f(3,8)" $ sound "snare:4"
                ]

     -- You can hear that the snares are 'filling in' where the kicks
     -- aren't playing - they never play at the same time.

     -- Filling in patterns like this is a lot of fun, and there's a
     -- function called 'stitch' that makes it easier:
     d1 $ stitch "t(3,8)" (sound "kick:4") (sound "snare:4")

     -- You only have to give the boolean pattern once, 'stitch' takes care
     -- of inverting the pattern for the second pattern. It's called
     -- 'stitch', because it's like going up and down to stitch two things
     -- together.

     -- You can make more complicated boolean patterns to quickly get some
     -- fun patterns going:
     d1 $ stitch "t(<3 5>,8,<0 2 3>)" (sound "kick:4") (sound "hc")

     d1 $ stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" (sound "kick:4") (sound "hc")

     -- Actually it'd be less typing do the stitching _inside_ the sound
     -- control pattern:
     d1 $ sound (stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" "kick:4" "hc")

     -- In the above, I only have to write 'sound' once, because the
     -- 'stitch' is working on patterns of words, not patterns of sounds.

     -- You can also alternate between patterns of true, and patterns of false
     -- values:
     drawLine $ struct "<t f>(3,8)" "a"

     -- If you prefer you can use '1' or '0' instead of 't' and 'f', the
     -- result is exactly the same:
     drawLine $ struct "<1 0>(3,8)" "a"

     d1 $ struct "<1 0>(3,8)" $ sound "clap"

     -- You don't have to use the Euclidean syntax, you can just right them
     -- out by hand:
     d1 $ stitch "t f t t f f t f" (sound "kick:4") (sound "hc")

     -- .. and use the usual mininotation syntax:
     d1 $ stitch "t f t [t f]*2 f ~ t f" (sound "kick:4") (sound "hc")
       # room 0.2 # sz 0.8

     -- With stitch, the rhythmic structure comes from the boolean
     -- pattern. It has a synonym friend called 'sew', which instead
     -- preserves the structure of the patterns it's sewing together.

     -- Lets try it:
     d1 $ sew "t f" (sound "kick") (sound "clap:4")

     -- Oh! We only hear the kick. That's because the 'f' only switches to
     -- the second pattern for the second half of the cycle, and no new
     -- 'clap's happen then.

     -- If we have four claps spread over the cycle, we hear the second two
     -- of them:
     d1 $ sew "t f" (sound "kick") (sound "clap:4*4")

     -- Sew can be really nice for blending together two more complicated
     -- patterns. Lets have a listen to them individually first:

     d1 $ chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu"

     d1 $ n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2

     -- And now sewn:
     d1 $ sew (iter 4 "t f")
       (chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu")
       (n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2)

     -- In the above I have a really simple "t f" binary pattern, but use
     -- 'iter 4' so that it shifts by a quarter every cycle.. So you get
     -- different parts of the sewn patterns coming through.



   -- Lets fit things from a list, into a pattern!

   -- Here's the 'type signature', what's it telling us?
   fit :: Int -> [a] -> Pattern Int -> Pattern a

   -- 'fit' takes a whole number, a list of things, a pattern of whole numbers,
   -- and then gives back a pattern of things.

   -- Int - a 'step size' - how far to advance through the list each cycle
   -- [a] - a list - the things you want to put in the tattern
   -- Pattern Int - a pattern of numbers referring to things in the list
   -- Pattern a - the result! 'Pattern a' means it can work with any kind of
   -- pattern

   -- Let's start simple, with a step size of 0

   d1 $ n (fit 0 [9,10,11,12,13,14] "0 1 2 3") # s "alphabet"

   -- That's just cycling through four letters of the alphabet (j,k,l,m).
   -- We have six numbers in our list, but we're only using the first four
   -- (from 0 to 3).

   -- Let's use all six, and add a bit more structure:
   d1 $ n (fit 0 [9,10,11,12,13,14] "[0 3] [1 2] 4 [~ 5]") # s "alphabet"

   -- Note that if you go past the end of the list, you go back to the start again.
   -- So '0' and '6' end up pointing at the first of the six numbers, which is '9'
   -- (which gives us 'j')
   d1 $ n (fit 0 [9,10,11,12,13,14] "0 6") # s "alphabet"

   -- Ok what if we start playing with that 'step size'?
   d1 $ n (fit 1 [9,10,11,12,13,14] "0 1 2 ~") # s "alphabet"

   -- It starts getting confusing, but you should be able to hear that each cycle,
   -- the pattern moves through the list by one step, until it gets back to the
   -- start again. So if it starts from 'j', 'k', 'l', the next cycle it'll shift
   -- along by one and give 'k', 'l', 'm', and so on, until it starts wrapping
   -- around to the start again.

   -- This can be nice for generating melodies. The rhythm stays the same, but
   -- the notes evolve, moving through the pattern
   d1 $ note (fit 2 [0,2,7,5,12] "0 ~ 1 [2 3]") # sound "supermandolin"
     # legato 2 # gain 1.3

   d2 $ n "0 ~ 2 [3*2 4*2]" # sound "cpu" # speed 2
